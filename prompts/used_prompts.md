# GitHub Search User 과제 진행 과정 정리

본 문서는 GitHub Search User 과제를 수행하며,
문제 해결 과정에서 단계적으로 제기한 질문과 고민,
그리고 테스트 전략이 어떻게 발전했는지를 정리한 기록이다.

---

## 1. 초기 문제 인식: 무한 스크롤과 요청 제어

### 질문

- 초기 진입 시 API 요청이 계속 발생하는데 왜 그런가?
- `rootMargin`을 어떻게 조정해야 하는가?
- TanStack Query처럼 React에서 무한 스크롤을 구현할 수 있는가?
- `enabled`, `retry` 옵션은 어떤 역할을 하는가?
- 최초 검색 시 데이터가 적을 경우 계속 호출되는 문제를 어떻게 막을 수 있는가?

### 핵심 고민

- **CSR 환경에서 IntersectionObserver가 언제 트리거되는가**
- **초기 렌더와 사용자 인터랙션(스크롤/검색)을 어떻게 구분할 것인가**

---

## 2. 검색 흐름과 CSR/SSR 경계에 대한 고민

### 질문

- 최초에는 서버에서 받아온 데이터를 보여주고,
  무한 스크롤이나 재검색 시에만 fetch를 해야 하지 않는가?
- 지금 요청은 CSR에서 발생하는 것 같은데, 이게 맞는 구조인가?
- `enabled`는 어디에서 오는 값인가? 선언된 곳이 없다.

### 핵심 고민

- **SSR 데이터 + CSR 추가 요청의 책임 분리**
- **“초기 데이터”와 “추가 데이터”의 경계 정의**

---

## 3. GitHub Search API 연동 및 정렬/필터 설계

### 질문

- `/github/search-users` API 호출이 어디에서도 보이지 않는데,
  실제로는 왜 호출되고 있는가?
- `searchParams`를 page에서 route로 넘기는 방식은 어떻게 설계해야 하는가?
- GitHub Search API에서 정렬 조건을 어떻게 지원할 수 있는가?
  - 기본
  - followers
  - repositories
  - joined
  - DESC

### 핵심 고민

- **UI 상태 → q 토큰 → API 파라미터 간의 일관성**
- **q 기반 검색 vs query param 기반 검색의 공존**

---

## 4. E2E 테스트 도입과 방향성 전환

### 질문

- Playwright로 E2E 테스트를 구성할 때,
  공통 로직이 많으면 POM 패턴을 꼭 써야 하는가?
- 테스트를 위해 mock data는 몇 개 정도가 적절한가?
- 조건에 맞는 mock 데이터를 10개 이상 만들어야 하지 않는가?

### 핵심 고민

- **과제 규모에서 POM이 오히려 과도한 추상화가 아닌가**
- **테스트 가독성과 유지보수성의 균형**

---

## 5. API Mocking 전략에 대한 고민

### 질문

- `page.route(...).fulfill({ json })` 패턴이 맞는 방식 아닌가?
- response를 이렇게 직접 호출하는 게 맞는가?
- Playwright Network / Mock 문서를 기준으로 다시 검증해달라.
- 서버에서 호출하는 API는 인터셉트가 안 되는가?

### 핵심 고민

- **Next.js API Route / BFF / 서버 호출의 인터셉트 한계**
- **E2E에서 “네트워크를 믿을 것인가, UI 결과를 믿을 것인가”**

---

## 6. 필터별 테스트 시나리오 확장

### 진행 순서

1. type filter
2. repos range
3. followers range
4. created range
5. location / language
6. sponsors:true

### 질문

- 필터 토글 시 q 토큰과 API 응답이 정말 일치하는가?
- `type:user`, `type:org` 토글 on/off는 어떻게 검증해야 하는가?
- range 필터는 UI 입력이 없을 때 어떻게 테스트해야 하는가?
- sponsors 필터는 `sponsors:true` vs `is:sponsorable` 중 무엇이 맞는가?

### 핵심 고민

- **UI 표현과 실제 API spec 불일치**
- **테스트가 구현을 강제하고 있는 건 아닌가**

---

## 7. Strict mode, locator 충돌, 테스트 안정성 문제

### 질문

- `getByTestId(...).or(...)`가 strict mode violation을 발생시키는 이유는?
- 동일한 role/button이 여러 개일 때 테스트는 어떻게 작성해야 하는가?
- `alice` 텍스트를 찾지 못하는 시나리오가 왜 발생하는가?

### 핵심 고민

- **테스트가 DOM 구조에 과도하게 의존하고 있지 않은가**
- **사용자 관점 vs 구현 관점 중 무엇을 우선할 것인가**

---

## 8. 정렬(sort) 필터 테스트에서의 깨달음

### 질문

- `sort:followers`가 q에 들어가지 않는데 테스트가 실패하는 이유는?
- 정렬은 q 토큰이 아니라 query param으로 처리되는 구조 아닌가?
- keyword를 비우면 왜 응답이 0개가 되는가?

### 핵심 깨달음

- **정렬 테스트에서도 “검색어”는 반드시 존재해야 한다**
- **sort는 결과의 순서를 검증a검하는 것이지, 결과 유무를 보장하지 않는다**

---

## 9. 무한 스크롤 E2E 테스트에 대한 관점 변화

### 질문

- 점진적으로 보이는 UI를 검증하는 게 맞는 테스트인가?
- 스크롤 시 page=2 요청이 꼭 발생해야 하는가?
- 이미 한 번에 많은 데이터가 내려오면 이 테스트는 무의미하지 않은가?

### 최종 결론

- ❌ “page=2 요청이 발생했는가”는 구현 종속적이다
- ✅ “사용자 스크롤 이후 더 많은 결과가 접근 가능해졌는가”를 검증해야 한다

즉,

- **네트워크 단위 테스트가 아니라**
- **사용자 경험 기반 E2E 테스트로 접근해야 한다**

---

## 10. 전체 과제에서 얻은 핵심 인사이트

- 테스트는 구현을 강제하면 안 된다
- E2E 테스트는 **“무엇을 보장하고 싶은가”**에서 출발해야 한다
- SSR/CSR 경계는 테스트보다 설계에서 먼저 정리되어야 한다
- 무한 스크롤은 “페이지 번호”가 아니라 “접근 가능한 데이터 범위”의 문제다

---

## 마무리

본 과제는 단순한 GitHub API 연동이 아니라,

- 검색 조건 모델링
- UI 상태와 API 파라미터의 일관성
- E2E 테스트의 책임 범위
- 무한 스크롤 UX 검증 방식

을 단계적으로 고민하고 수정해 나가는 과정이었다.

이 문서는 그 **사고 과정과 기술적 판단의 기록**이다.
